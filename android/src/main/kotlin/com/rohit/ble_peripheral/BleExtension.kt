package com.rohit.ble_peripheral

import android.app.Activity
import android.bluetooth.BluetoothDevice
import android.bluetooth.BluetoothGattCharacteristic
import android.bluetooth.BluetoothGattDescriptor
import android.bluetooth.BluetoothGattService
import android.content.pm.PackageManager
import android.util.Log
import java.lang.Exception
import java.util.Collections
import java.util.UUID

data class BleCharCache(
    val uuid: String,
    val instanceId: Int?,
    val char: BluetoothGattCharacteristic,
)

private val bluetoothGattCharacteristics: MutableList<BleCharCache> = mutableListOf()
private val descriptorValueReadMap: MutableMap<String, ByteArray> =
    HashMap()
private val instanceIdMap: MutableMap<Int, Int> =
    HashMap()
const val descriptorCCUUID = "00002902-0000-1000-8000-00805f9b34fb"


fun Activity.havePermission(permissions: Array<String>): Boolean {
    var allPermissionProvided = true
    for (perm in permissions) {
        val checkVal = checkCallingOrSelfPermission(perm)
        if (checkVal != PackageManager.PERMISSION_GRANTED) {
            allPermissionProvided = false
            break;
        }
    }
    return allPermissionProvided
}


/// From Flutter -> Native
fun BleService.toGattService(): BluetoothGattService {
    val service = BluetoothGattService(
        UUID.fromString(uuid),
        if (primary) BluetoothGattService.SERVICE_TYPE_PRIMARY else BluetoothGattService.SERVICE_TYPE_SECONDARY
    )
    characteristics.forEach {
        it.toGattCharacteristic().let { characteristic ->
            service.addCharacteristic(characteristic)
        }
    }
    return service
}

fun BleCharacteristic.toGattCharacteristic(): BluetoothGattCharacteristic {
    val char = BluetoothGattCharacteristic(
        UUID.fromString(uuid),
        properties.toPropertiesList(),
        permissions.toPermissionsList()
    )

    // Store instance Id in map to identify
    instanceId?.let {
        instanceIdMap[char.instanceId] = it.toInt()
    }

    value?.let {
        char.value = it
    }
    descriptors?.forEach {
        it.toGattDescriptor().let { descriptor ->
            char.addDescriptor(descriptor)
        }
    }

    addCCDescriptorIfRequired(this, char)


    if (instanceId == null) {
        // Then all good, make sure only one char exists
        if (bluetoothGattCharacteristics.any { it.uuid == char.uuid.toString() }) {
            throw FlutterError(code = "Failed", message = "Char already exists")
        }
        bluetoothGattCharacteristics.add(BleCharCache(uuid, null, char))
    } else {
        // Make sure this instanceId does not exists
        if (bluetoothGattCharacteristics.any { it.uuid == char.uuid.toString() && it.instanceId == instanceId.toInt() }) {
            throw FlutterError(
                code = "Failed",
                message = "Char already exists with this instance id"
            )
        }
        bluetoothGattCharacteristics.add(BleCharCache(uuid, instanceId.toInt(), char))
    }

    return char
}

fun addCCDescriptorIfRequired(
    bleCharacteristic: BleCharacteristic,
    char: BluetoothGattCharacteristic,
) {
    val haveNotifyOrIndicateProperty =
        char.properties and BluetoothGattCharacteristic.PROPERTY_NOTIFY != 0 ||
                char.properties and BluetoothGattCharacteristic.PROPERTY_INDICATE != 0
    if (!haveNotifyOrIndicateProperty) return

    var cccdDescriptorAlreadyAdded = false
    for (descriptor in bleCharacteristic.descriptors ?: Collections.emptyList()) {
        if (descriptor.uuid.lowercase() == descriptorCCUUID.lowercase()) {
            cccdDescriptorAlreadyAdded = true
            break
        }
    }

    if (cccdDescriptorAlreadyAdded) return

    val cccdDescriptor = BluetoothGattDescriptor(
        UUID.fromString(descriptorCCUUID),
        BluetoothGattDescriptor.PERMISSION_READ or BluetoothGattDescriptor.PERMISSION_WRITE
    )
    cccdDescriptor.value = BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE
    char.addDescriptor(cccdDescriptor)
    Log.d("BlePeripheral", "Added CCCD for ${char.uuid}")
}

fun BluetoothGattDescriptor.getCacheValue(): ByteArray? {
    return descriptorValueReadMap[uuid.toString().lowercase()]
}

fun ByteArray.toIntArray(): List<Int> {
    val data: MutableList<Int> = mutableListOf()
    for (i in this.indices) {
        data.add(this[i].toInt())
    }
    return data
}

fun BleDescriptor.toGattDescriptor(): BluetoothGattDescriptor {
    val defaultPermission =
        BluetoothGattDescriptor.PERMISSION_READ or BluetoothGattDescriptor.PERMISSION_WRITE
    val permission = permissions?.toPermissionsList() ?: defaultPermission
    val descriptor = BluetoothGattDescriptor(
        UUID.fromString(uuid),
        permission
    )
    value?.let {
        descriptor.value = it
        descriptorValueReadMap[uuid.lowercase()] = it
    }
    return descriptor
}

fun String.findCharacteristic(instanceId: Long?): BluetoothGattCharacteristic? {
    if (instanceId != null) {
        return bluetoothGattCharacteristics.find { it.uuid == this && instanceId.toInt() == it.instanceId }?.char
    }
    return bluetoothGattCharacteristics.find { it.uuid == this }?.char
}

fun String.findService(): BluetoothGattService? {
    for (char in bluetoothGattCharacteristics) {
        if (char.char.service?.uuid.toString() == this) {
            return char.char.service
        }
    }
    return null
}

fun List<CharacteristicProperties>.toPropertiesList(): Int {
    return this.map { it }.fold(0) { acc, i -> acc or i.toProperties() }.toInt()
}

fun List<AttributePermissions>.toPermissionsList(): Int {
    return this.map { it }.fold(0) { acc, i -> acc or i.toPermission() }.toInt()
}

fun CharacteristicProperties.toProperties(): Int {
    return when (this) {
        CharacteristicProperties.BROADCAST -> BluetoothGattCharacteristic.PROPERTY_BROADCAST
        CharacteristicProperties.READ -> BluetoothGattCharacteristic.PROPERTY_READ
        CharacteristicProperties.WRITE_WITHOUT_RESPONSE -> BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE
        CharacteristicProperties.WRITE -> BluetoothGattCharacteristic.PROPERTY_WRITE
        CharacteristicProperties.NOTIFY -> BluetoothGattCharacteristic.PROPERTY_NOTIFY
        CharacteristicProperties.INDICATE -> BluetoothGattCharacteristic.PROPERTY_INDICATE
        CharacteristicProperties.AUTHENTICATED_SIGNED_WRITES -> BluetoothGattCharacteristic.PROPERTY_SIGNED_WRITE
        CharacteristicProperties.EXTENDED_PROPERTIES -> BluetoothGattCharacteristic.PROPERTY_EXTENDED_PROPS
        CharacteristicProperties.NOTIFY_ENCRYPTION_REQUIRED -> BluetoothGattCharacteristic.PROPERTY_NOTIFY //  NotifyEncryptionRequired
        CharacteristicProperties.INDICATE_ENCRYPTION_REQUIRED -> BluetoothGattCharacteristic.PROPERTY_INDICATE //   IndicateEncryptionRequired
    }
}

fun AttributePermissions.toPermission(): Int {
    return when (this) {
        AttributePermissions.READABLE -> BluetoothGattCharacteristic.PERMISSION_READ
        AttributePermissions.WRITEABLE -> BluetoothGattCharacteristic.PERMISSION_WRITE
        AttributePermissions.READ_ENCRYPTION_REQUIRED -> BluetoothGattCharacteristic.PERMISSION_READ_ENCRYPTED
        AttributePermissions.WRITE_ENCRYPTION_REQUIRED -> BluetoothGattCharacteristic.PERMISSION_WRITE_ENCRYPTED
    }
}

fun Int.toBondState(): BondState {
    return when (this) {
        BluetoothDevice.BOND_BONDING -> BondState.BONDING
        BluetoothDevice.BOND_BONDED -> BondState.BONDED
        BluetoothDevice.BOND_NONE -> BondState.NONE
        else -> BondState.NONE
    }
}

fun Int.toGivenInstanceId(): Long? {
    return instanceIdMap[this]?.toLong()
}